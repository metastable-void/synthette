<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Synthette</title>
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"/>
        <style>
            :root {
                display: grid;
                min-width: 100%;
                min-height: 100%;
            }

            body {
                display: grid;
                margin: 0;
            }

            #keyboard {
                display: grid;
            }
        </style>
        <template id="synthette-keyboard">
            <style>
                @namespace url(http://www.w3.org/1999/xhtml);
                @namespace svg url(http://www.w3.org/2000/svg);

                :host {
                    display: grid;
                }

                #main {
                    overflow: hidden;
                }

                svg|*#grid > svg|rect {
                    fill: #ccc;
                }

                svg|*#grid > svg|rect.base {
                    fill: #333;
                }
            </style>
            <div id="main">
                <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
                    <g id="grid"></g>
                </svg>
            </div>
        </template>
    </head>
    <body>
        <synthette-keyboard id="keyboard"></synthette-keyboard>
        <script type="module">
            customElements.define('synthette-keyboard', class SynthetteKeyboard extends HTMLElement {
                constructor() {
                    //
                    super();
                    let pointerActive = false;
                    const pointers = new Map;
                    let previousValue = -1;

                    this.value = 0;

                    const template = document.getElementById('synthette-keyboard');
                    const shadowRoot = this.attachShadow({mode: 'open'});
                    shadowRoot.append(template.content.cloneNode(true));
                    const main = shadowRoot.getElementById('main');
                    const left = shadowRoot.getElementById('left');
                    const right = shadowRoot.getElementById('right');

                    const grid = shadowRoot.getElementById('grid');
                    const gridRepeatX = 3;
                    const gridCountX = 12 * gridRepeatX;
                    const gridRepeatY = 8;
                    for (let i = 1; i < gridCountX; i++) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        line.setAttribute('width', '1px');
                        line.setAttribute('height', '100%');
                        line.setAttribute('x', `${100 * i / gridCountX}%`);
                        line.setAttribute('y', '0');
                        if (0 == (i % 12)) {
                            line.classList.add('base');
                        }
                        grid.appendChild(line);
                    }

                    for (let i = 1; i < gridRepeatY; i++) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        line.setAttribute('width', '100%');
                        line.setAttribute('height', '1px');
                        line.setAttribute('x', '0');
                        line.setAttribute('y', `${100 * i / gridRepeatY}%`);
                        grid.appendChild(line);
                    }

                    const pointerHandler = (ev, aValueX, aValueY, pointerId) => {
                        if (!pointers.has(pointerId)) {
                            pointers.set(pointerId, {
                                active: false,
                                previousValue: -1,
                            });
                        }
                        const pointer = pointers.get(pointerId);
                        if (ev.buttons && ev.type != 'pointerleave'
                            && aValueX >= 0 && aValueX <= 1 && aValueY >= 0 && aValueY <= 1) {
                            const valueX = aValueX * gridRepeatX;
                            const valueY = gridRepeatY - Math.floor(aValueY * gridRepeatY) - 1;
                            if (!pointer.active) {
                                pointer.active = true;
                                this.dispatchEvent(new CustomEvent('activate', {
                                    detail: {
                                        pointerId,
                                        valueX,
                                        valueY,
                                    },
                                }));
                            }
                            if (pointer.previousValue != aValueX) {
                                pointer.previousValue = aValueX;
                                this.dispatchEvent(new CustomEvent('valueChange', {
                                    detail: {
                                        pointerId,
                                        valueX,
                                        valueY,
                                    },
                                }));
                            }
                        } else if (pointer.active) {
                            const valueX = aValueX * gridRepeatX;
                            const valueY = gridRepeatY - Math.floor(aValueY * gridRepeatY) - 1;
                            pointer.active = false;
                            pointer.previousValue = -1;
                            this.dispatchEvent(new CustomEvent('deactivate', {
                                detail: {
                                    pointerId,
                                    valueX,
                                    valueY,
                                },
                            }));
                        }
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                    };

                    main.addEventListener('pointerdown', (ev) =>
                        pointerHandler(ev, ev.offsetX / main.clientWidth, ev.offsetY / main.clientHeight, ev.pointerId));
                    main.addEventListener('pointermove', (ev) =>
                        pointerHandler(ev, ev.offsetX / main.clientWidth, ev.offsetY / main.clientHeight, ev.pointerId));
                    main.addEventListener('pointerup', (ev) =>
                        pointerHandler(ev, ev.offsetX / main.clientWidth, ev.offsetY / main.clientHeight, ev.pointerId));
                    main.addEventListener('pointerenter', (ev) =>
                        pointerHandler(ev, ev.offsetX / main.clientWidth, ev.offsetY / main.clientHeight, ev.pointerId));
                    main.addEventListener('pointerleave', (ev) =>
                        pointerHandler(ev, ev.offsetX / main.clientWidth, ev.offsetY / main.clientHeight, ev.pointerId));
                    
                    main.addEventListener('touchmove', (ev) => {
                        ev.preventDefault();
                        ev.stopImmediatePropagation();
                    });
                }
            });

            const ctx = new (window.AudioContext || window.webkitAudioContext);
            const oscillators = new Map;

            const keyboard = document.querySelector('#keyboard');
            keyboard.addEventListener('activate', (ev) => {
                console.log('activate');
                if (!oscillators.has(ev.detail.pointerId)) {
                    console.log('New oscillator: %d', ev.pointerId);
                    const oscillatorNode = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    oscillators.set(ev.detail.pointerId, {
                        oscillatorNode,
                        gainNode,
                    });
                    oscillatorNode.connect(gainNode);
                    oscillatorNode.frequency.setValueAtTime(440, ctx.currentTime);
                    gainNode.connect(ctx.destination);
                    gainNode.gain.setValueAtTime(0, ctx.currentTime);
                    oscillatorNode.start();
                }
                const {gainNode, oscillatorNode} = oscillators.get(ev.detail.pointerId);
                gainNode.gain.linearRampToValueAtTime(1, ctx.currentTime + 0.1);
            });
            keyboard.addEventListener('valueChange', (ev) => {
                const {gainNode, oscillatorNode} = oscillators.get(ev.detail.pointerId);
                console.log('valueChange: (%f, %d)', ev.detail.valueX, ev.detail.valueY);
                oscillatorNode.frequency.linearRampToValueAtTime(27.5 * 2 ** (ev.detail.valueX + ev.detail.valueY), ctx.currentTime + 0.1);
            });
            keyboard.addEventListener('deactivate', (ev) => {
                console.log('deactivate');
                const {gainNode, oscillatorNode} = oscillators.get(ev.detail.pointerId);
                gainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
            });
        </script>
    </body>
</html>